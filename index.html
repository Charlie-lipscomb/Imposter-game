<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Imposter — Guess the Word</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#0f1724;color:#e8f0fb;display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0}
  .card{background:#1a1f2b;padding:18px;border-radius:12px;width:680px;max-width:96%}
  input,button,textarea{width:100%;padding:10px;margin:6px 0;border-radius:6px;border:none;box-sizing:border-box}
  .btn-primary{background:#4a90e2;color:white}
  .btn-success{background:#28a745;color:white}
  .player-list div,.clue-item{padding:8px;background:rgba(255,255,255,0.03);margin-bottom:6px;border-radius:6px}
  #gameUI,#voteSection{display:none}
  .small{font-size:13px;color:#9aa7b7}
  .row{display:flex;gap:8px}
  .col2{flex:1}
  .inline-btn{width:auto;padding:8px 12px}
  #results{margin-top:12px;padding:10px;background:#22303f;border-radius:8px;white-space:pre-wrap}
  .selected{outline:2px solid #fff}
</style>
</head>
<body>
  <div class="card" id="lobbyCard">
    <h2>Imposter — Guess the Word</h2>

    <label class="small">Your name</label>
    <input id="name" placeholder="Your name" />

    <div class="row">
      <button id="createBtn" class="btn-primary inline-btn">Create Lobby</button>
      <input id="joinCode" placeholder="Lobby Code" class="col2" />
      <button id="joinBtn" class="btn-primary inline-btn">Join</button>
    </div>

    <div id="playersCard" style="display:none;margin-top:12px">
      <div class="row" style="align-items:center;justify-content:space-between">
        <div>Lobby Code: <strong id="codeDisplay">—</strong></div>
        <div class="small">Players: <span id="playersCount">0</span></div>
      </div>

      <div id="playersList" class="player-list" style="margin-top:8px"></div>
      <div style="margin-top:10px">
        <button id="startBtn" class="btn-success" style="display:none">Start Game</button>
      </div>
      <div class="small" style="margin-top:8px">Host can start the game once there are at least 3 players</div>
    </div>
  </div>

  <!-- Game UI -->
  <div class="card" id="gameUI">
    <h2>Game In Progress</h2>
    <div class="small" id="roleDisplay">Role: —</div>
    <div class="small" id="wordDisplay" style="margin-bottom:8px">Word: —</div>

    <h3>Clues (everyone sees them)</h3>
    <div id="clueList" style="max-height:200px;overflow:auto;margin-bottom:8px"></div>

    <div id="turnArea" style="margin-top:8px">
      <div id="turnInfo" class="small" style="margin-bottom:6px">Turn info</div>
      <div id="clueSection">
        <textarea id="clueInput" placeholder="Write a short clue (no full word)"></textarea>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="submitClueBtn" class="btn-primary inline-btn">Submit clue</button>
          <div class="small">Rounds: <span id="roundCounter">0</span> / 2</div>
        </div>
      </div>
    </div>

    <div id="voteSection" style="margin-top:12px">
      <h3>Vote for the Imposter</h3>
      <div id="voteList" style="margin-bottom:8px"></div>
      <button id="submitVoteBtn" class="btn-success">Submit Vote</button>
    </div>

    <div id="results"></div>
  </div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
import {
  getDatabase, ref, set, get, onValue, update, serverTimestamp
} from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyDlm1nd6P6VY6HiFLgy2rZPeLLr-VwYaD4",
  authDomain: "imposter-5142b.firebaseapp.com",
  databaseURL: "https://imposter-5142b-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "imposter-5142b",
  storageBucket: "imposter-5142b.appspot.com",
  messagingSenderId: "500677632460",
  appId: "1:500677632460:web:236568f1cb93c31a7bbd69",
  measurementId: "G-RWF1030VF1"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

let clientId = localStorage.getItem('imposter_clientId') || ('c_'+Math.random().toString(36).slice(2,10));
localStorage.setItem('imposter_clientId', clientId);

let currentLobby = null;
const roundsNeeded = 2; // two full rounds

const el = id => document.getElementById(id);

let votesListenerAttached = false;

function renderPlayers(players){
  const list = el('playersList'); list.innerHTML = '';
  const keys = Object.keys(players || {});
  keys.forEach(k=>{
    const p = players[k];
    const div = document.createElement('div');
    div.textContent = (p.name || 'Unknown') + (k === clientId ? ' (you)' : '');
    list.appendChild(div);
  });
  el('playersCount').textContent = keys.length;
}

// start button visible only to host and when ≥3 players
function updateStartVisibility(hostId, players){
  const keys = Object.keys(players || {});
  el('startBtn').style.display = (hostId === clientId && keys.length >= 3) ? 'inline-block' : 'none';
}

// render clues list (everyone sees clues)
function renderClues(clues = [], players = {}){
  const list = el('clueList'); list.innerHTML = '';
  (clues || []).forEach(c=>{
    const div = document.createElement('div');
    div.className = 'clue-item';
    const name = players?.[c.player]?.name || 'Unknown';
    const time = c.ts ? new Date(c.ts).toLocaleTimeString() : '';
    div.innerHTML = `<strong>${name}:</strong> ${c.text} <span class="small"> ${time}</span>`;
    list.appendChild(div);
  });
}

function updateTurnUI(lobby){
  const me = clientId;
  const players = lobby.players || {};
  const order = lobby.turnOrder || Object.keys(players);
  const currentTurnIdx = lobby.currentTurn || 0;
  const totalClues = (lobby.clues || []).length;
  const round = Math.floor(totalClues / order.length) + 1; // 1-based
  el('roundCounter').textContent = Math.min(roundsNeeded, round);
  // if rounds exceeded, voting should have started already
  const currentPlayerId = order[currentTurnIdx];
  if(lobby.voting){
    el('turnInfo').textContent = 'Voting in progress';
    el('clueSection').style.display = 'none';
    el('voteSection').style.display = 'block';
    return;
  }
  el('voteSection').style.display = 'none';
  if(currentPlayerId === me){
    el('turnInfo').textContent = 'It is your turn. Give a clue.';
    el('clueSection').style.display = 'block';
  } else {
    const playerName = players?.[currentPlayerId]?.name || 'Unknown';
    el('turnInfo').textContent = `Waiting for ${playerName} to give a clue.`;
    el('clueSection').style.display = 'none';
  }
}

// show final results for everyone if stored
function showFinalResultsIfAny(data){
  if(!data || !data.finalResults) return;
  const fr = data.finalResults;
  let html = '';
  html += fr.text + '\n\n';
  html += 'Roles: ' + (fr.roles || '') + '\n';
  html += 'Word: ' + (fr.word || '—') + '\n';
  if(fr.tally){
    html += '\nVotes tally:\n';
    Object.keys(fr.tally).forEach(k => {
      const n = fr.tally[k];
      const name = data.players?.[k]?.name || k;
      html += `${name}: ${n}\n`;
    });
  }
  el('results').textContent = ''; // clear first
  el('results').innerText = html;
}

// start listening to lobby changes
function listenLobby(lobbyCode){
  currentLobby = lobbyCode;
  const lobbyRef = ref(db, 'lobbies/' + lobbyCode);
  onValue(lobbyRef, snap=>{
    const data = snap.val();
    if(!data) return;
    // update players list and start button visibility
    renderPlayers(data.players || {});
    updateStartVisibility(data.hostId, data.players || {});
    // if final results exist show them (persisted)
    showFinalResultsIfAny(data);
    // if game started, show game UI
    if(data.started){
      el('lobbyCard').style.display = 'none';
      el('gameUI').style.display = 'block';
      // role and word
      const role = data.players?.[clientId]?.role || 'Unknown';
      el('roleDisplay').textContent = 'Your role: ' + role;
      el('wordDisplay').textContent = 'Word: ' + (role === 'imposter' ? '???' : (data.word || '—'));
      // render clues
      renderClues(data.clues || [], data.players || {});
      // automatically start voting if enough clues (two full rounds)
      const playersCount = Object.keys(data.players || {}).length || 0;
      const totalClues = (data.clues || []).length;
      if(!data.voting && playersCount>0 && totalClues >= roundsNeeded * playersCount){
        // begin voting
        update(ref(db, 'lobbies/' + currentLobby), { voting: true });
        return;
      }
      // if voting is active, render vote UI
      if(data.voting){
        renderVoteUI(data);
      } else {
        // hide vote UI if not voting
        el('voteSection').style.display = 'none';
      }
      updateTurnUI(data);
    } else {
      // not started: show lobby UI
      el('lobbyCard').style.display = 'block';
      el('gameUI').style.display = 'none';
      el('playersCard').style.display = 'block';
      el('codeDisplay').textContent = lobbyCode;
    }
  });
}

// render vote UI: buttons for each player
function renderVoteUI(lobby){
  el('clueSection').style.display = 'none';
  el('voteSection').style.display = 'block';
  const list = el('voteList'); list.innerHTML = '';
  const players = lobby.players || {};
  Object.keys(players).forEach(id=>{
    const btn = document.createElement('button');
    btn.textContent = players[id].name + (id === clientId ? ' (you)' : '');
    btn.style.width = '100%';
    btn.style.margin = '6px 0';
    btn.onclick = ()=> {
      // mark current selection
      const prev = list.querySelector('.selected');
      if(prev) prev.classList.remove('selected');
      btn.classList.add('selected');
      btn.dataset.target = id;
    };
    list.appendChild(btn);
  });
  // enable submit button
  el('submitVoteBtn').disabled = false;
}

// tally votes once all players voted
function watchVotesAndTally(){
  if(votesListenerAttached) return;
  votesListenerAttached = true;

  const votesRef = ref(db, 'lobbies/' + currentLobby + '/votes');
  onValue(votesRef, async snap=>{
    const votesObj = snap.val() || {};
    // need number of players
    const lobbySnap = await get(ref(db, 'lobbies/' + currentLobby));
    const lobby = lobbySnap.val();
    if(!lobby) return;
    const players = lobby?.players || {};
    const nPlayers = Object.keys(players).length;
    if(Object.keys(votesObj).length < nPlayers) return; // wait for everyone
    // compute tally
    const tally = {};
    Object.keys(votesObj).forEach(voterId=>{
      const target = votesObj[voterId].vote;
      tally[target] = (tally[target] || 0) + 1;
    });
    // find max
    let max = -1, winners = [];
    for(const target in tally){
      if(tally[target] > max){ max = tally[target]; winners = [target]; }
      else if(tally[target] === max){ winners.push(target); }
    }
    let resultText = '';
    let ejectedId = null;
    if(winners.length !== 1){
      resultText = 'Tie. No one is ejected.';
    } else {
      ejectedId = winners[0];
      const ejectedName = players[ejectedId].name;
      const wasImposter = players[ejectedId].role === 'imposter';
      resultText = `Voted out: ${ejectedName}. They ${wasImposter ? 'were' : 'were not'} the imposter.`;
    }
    // prepare finalResults object (persist so everyone sees)
    const rolesText = Object.keys(players).map(pid=>{
      return `${players[pid].name}: ${players[pid].role}`;
    }).join('  |  ');
    const finalResults = {
      text: resultText,
      roles: rolesText,
      word: lobby.word || '—',
      tally: tally
    };
    // persist final results and clear voting flag (do not set started:false so UX can decide)
    await update(ref(db, 'lobbies/' + currentLobby), { finalResults, voting: false });
  });
}

// utilities
function genCode(){ return Math.random().toString(36).substring(2,8).toUpperCase(); }

// create / join / start / clue / vote handlers
async function createLobby(){
  const name = el('name').value.trim();
  if(!name) return alert('Enter your name');
  const code = genCode();
  currentLobby = code;
  // create lobby and add player under clientId
  await set(ref(db, 'lobbies/' + code), { hostId: clientId, started: false, created: serverTimestamp() });
  await set(ref(db, 'lobbies/' + code + '/players/' + clientId), { name, clientId });
  localStorage.setItem('imposter_lobby', code);
  localStorage.setItem('imposter_playerId', clientId);
  el('playersCard').style.display = 'block';
  el('codeDisplay').textContent = code;
  listenLobby(code);
  watchVotesAndTally();
}

async function joinLobby(){
  const name = el('name').value.trim();
  const code = el('joinCode').value.trim().toUpperCase();
  if(!name || !code) return alert('Enter name and code');
  const snap = await get(ref(db, 'lobbies/' + code));
  if(!snap.exists()) return alert('Lobby not found');
  currentLobby = code;
  await set(ref(db, 'lobbies/' + code + '/players/' + clientId), { name, clientId });
  localStorage.setItem('imposter_lobby', code);
  localStorage.setItem('imposter_playerId', clientId);
  el('playersCard').style.display = 'block';
  el('codeDisplay').textContent = code;
  listenLobby(code);
  watchVotesAndTally();
}

async function startGame(){
  if(!currentLobby) return;
  const lobbySnap = await get(ref(db, 'lobbies/' + currentLobby));
  if(!lobbySnap.exists()) return alert('Lobby not found');
  const lobby = lobbySnap.val();
  const players = lobby.players || {};
  const keys = Object.keys(players);
  if(keys.length < 3) return alert('Need at least 3 players to start');
  // choose imposter randomly
  const imposter = keys[Math.floor(Math.random() * keys.length)];
  // choose word (you can customise or load packs)
  const words = ['apple','dog','sun','car','book','river','moon','castle','guitar','pizza'];
  const word = words[Math.floor(Math.random()*words.length)];
  // create turn order = shuffled keys
  const shuffled = keys.slice().sort(()=>Math.random()-0.5);
  // set roles and initial lobby state
  const updates = {
    started: true,
    voting: false,
    word: word,
    turnOrder: shuffled,
    currentTurn: 0,
    clues: []
  };
  keys.forEach(k=>{
    updates['players/' + k + '/role'] = (k === imposter) ? 'imposter' : 'player';
  });
  // clear any previous votes and final results
  await update(ref(db, 'lobbies/' + currentLobby), updates);
  await set(ref(db, 'lobbies/' + currentLobby + '/votes'), {});
  await update(ref(db, 'lobbies/' + currentLobby), { finalResults: null });
}

el('createBtn').onclick = createLobby;
el('joinBtn').onclick = joinLobby;
el('startBtn').onclick = startGame;

// submit clue: append to /clues and advance turn
el('submitClueBtn').onclick = async () => {
  if(!currentLobby) return alert('No lobby');
  const text = el('clueInput').value.trim();
  if(!text) return alert('Enter a clue');
  const clueRef = ref(db, 'lobbies/' + currentLobby + '/clues');
  const newClue = { player: clientId, text, ts: Date.now() };
  const snap = await get(clueRef);
  const arr = snap.val() || [];
  arr.push(newClue);
  await set(clueRef, arr);
  el('clueInput').value = '';
  // advance turn index and also update clues in lobby root for convenience
  const lobbyRef = ref(db, 'lobbies/' + currentLobby);
  const lobbySnap = await get(lobbyRef);
  const lobby = lobbySnap.val();
  const order = lobby.turnOrder || Object.keys(lobby.players || {});
  let next = (lobby.currentTurn || 0) + 1;
  if(next >= order.length) next = 0;
  await update(lobbyRef, { currentTurn: next, clues: arr });
};

// voting: user selects button, then submit
el('submitVoteBtn').onclick = async () => {
  if(!currentLobby) return alert('No lobby');
  const list = el('voteList');
  const selected = list.querySelector('.selected');
  if(!selected) return alert('Select someone to vote for');
  const targetId = selected.dataset.target;
  // write vote under /votes/<clientId> = { vote: targetId }
  await set(ref(db, 'lobbies/' + currentLobby + '/votes/' + clientId), { vote: targetId });
  // disabling submit to avoid double votes
  el('submitVoteBtn').disabled = true;
};

// attach vote watcher once if lobby exists
function ensureWatchVotes(){
  if(!votesListenerAttached && currentLobby){
    watchVotesAndTally();
  }
}
window.addEventListener('load', ()=>{
  // auto rejoin if stored
  const saved = localStorage.getItem('imposter_lobby');
  if(saved){
    currentLobby = saved;
    listenLobby(saved);
    ensureWatchVotes();
  }
});

// call watchVotesAndTally when lobby created/joined inside those functions already

</script>
</body>
</html>
