<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Imposter - Guess the Word</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#0f1724;color:#e8f0fb;display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0}
  .card{background:#1a1f2b;padding:18px;border-radius:12px;width:680px;max-width:96%}
  input,button,textarea{width:100%;padding:10px;margin:6px 0;border-radius:6px;border:none;box-sizing:border-box}
  .btn-primary{background:#4a90e2;color:white}
  .btn-success{background:#28a745;color:white}
  .player-list div,.clue-item{padding:8px;background:rgba(255,255,255,0.03);margin-bottom:6px;border-radius:6px}
  #gameUI,#voteSection{display:none}
  .small{font-size:13px;color:#9aa7b7}
  .row{display:flex;gap:8px}
  .col2{flex:1}
  .inline-btn{width:auto;padding:8px 12px}
  #results{margin-top:12px;padding:10px;background:#22303f;border-radius:8px}
</style>
</head>
<body>
  <div class="card" id="lobbyCard">
    <h2>Imposter - Guess the Word</h2>

    <label class="small">Your name</label>
    <input id="name" placeholder="Your name" />

    <div class="row">
      <button id="createBtn" class="btn-primary inline-btn">Create Lobby</button>
      <input id="joinCode" placeholder="Lobby Code" class="col2" />
      <button id="joinBtn" class="btn-primary inline-btn">Join</button>
    </div>

    <div id="playersCard" style="display:none;margin-top:12px">
      <div class="row" style="align-items:center;justify-content:space-between">
        <div>Lobby Code: <strong id="codeDisplay">-</strong></div>
        <div class="small">Players: <span id="playersCount">0</span></div>
      </div>

      <div id="playersList" class="player-list" style="margin-top:8px"></div>
      <div style="margin-top:10px">
        <button id="startBtn" class="btn-success" style="display:none">Start Game</button>
      </div>
      <div class="small" style="margin-top:8px">Host can start the game once there are at least 3 players</div>
    </div>
  </div>

  <!-- Game UI -->
  <div class="card" id="gameUI">
    <h2>Game In Progress</h2>
    <div class="small" id="roleDisplay">Role: -</div>
    <div class="small" id="wordDisplay" style="margin-bottom:8px">Word: -</div>

    <h3>Clues (everyone sees them)</h3>
    <div id="clueList" style="max-height:200px;overflow:auto;margin-bottom:8px"></div>

    <div id="turnArea" style="margin-top:8px">
      <div id="turnInfo" class="small" style="margin-bottom:6px">Turn info</div>
      <div id="clueSection">
        <textarea id="clueInput" placeholder="Write a short clue (no full word)"></textarea>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="submitClueBtn" class="btn-primary inline-btn">Submit clue</button>
          <div class="small">Rounds: <span id="roundCounter">0</span> / 2</div>
        </div>
      </div>
    </div>

    <div id="voteSection" style="margin-top:12px">
      <h3>Vote for the Imposter</h3>
      <div id="voteList" style="margin-bottom:8px"></div>
      <button id="submitVoteBtn" class="btn-success">Submit Vote</button>
    </div>

    <div id="results"></div>
  </div>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
import {
  getDatabase, ref, set, get, onValue, update, serverTimestamp
} from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyCXqev3PU7OfSRtDJ6BGQ3Alz3n2_lwuAk",
  authDomain: "imposter-game-3b77e.firebaseapp.com",
  databaseURL: "https://imposter-game-3b77e-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "imposter-game-3b77e",
  storageBucket: "imposter-game-3b77e.firebasestorage.app",
  messagingSenderId: "929913946798",
  appId: "1:929913946798:web:e961f81be2c95b284f633f",
  measurementId: "G-KQNCHZH2EL"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

let clientId = localStorage.getItem('imposter_clientId') || ('c_'+Math.random().toString(36).slice(2,10));
localStorage.setItem('imposter_clientId', clientId);

let currentLobby = null;
const roundsNeeded = 2;

const el = id => document.getElementById(id);

// render functions
function renderPlayers(players){
  const list = el('playersList'); list.innerHTML = '';
  const keys = Object.keys(players || {});
  keys.forEach(k=>{
    const p = players[k];
    const div = document.createElement('div');
    div.textContent = (p.name || 'Unknown') + (k === clientId ? ' (you)' : '');
    list.appendChild(div);
  });
  el('playersCount').textContent = keys.length;
}

function updateStartVisibility(hostId, players){
  const keys = Object.keys(players || {});
  el('startBtn').style.display = (hostId === clientId && keys.length >= 3) ? 'inline-block' : 'none';
}

function renderClues(clues = [], players = {}){
  const list = el('clueList'); list.innerHTML = '';
  (clues || []).forEach(c=>{
    const div = document.createElement('div');
    div.className = 'clue-item';
    const name = players?.[c.player]?.name || 'Unknown';
    const time = c.ts ? new Date(c.ts).toLocaleTimeString() : '';
    div.innerHTML = `<strong>${name}:</strong> ${escapeHtml(c.text)} <span class="small"> ${time}</span>`;
    list.appendChild(div);
  });
}

function escapeHtml(text){
  if(!text) return '';
  return text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function updateTurnUI(lobby){
  const me = clientId;
  const players = lobby.players || {};
  const order = lobby.turnOrder || Object.keys(players || {});
  const currentTurnIdx = typeof lobby.currentTurn === 'number' ? lobby.currentTurn : 0;
  const totalClues = (lobby.clues || []).length;
  const orderLength = order.length || 1;
  const round = Math.floor(totalClues / orderLength) + 1;
  el('roundCounter').textContent = Math.min(roundsNeeded, round);

  const currentPlayerId = order[currentTurnIdx];
  if(lobby.voting){
    el('turnInfo').textContent = 'Voting in progress';
    el('clueSection').style.display = 'none';
    el('voteSection').style.display = 'block';
    renderVoteList(lobby);
    return;
  }

  el('voteSection').style.display = 'none';
  if(currentPlayerId === me){
    el('turnInfo').textContent = 'It is your turn. Give a clue.';
    el('clueSection').style.display = 'block';
  } else {
    const playerName = players?.[currentPlayerId]?.name || 'Unknown';
    el('turnInfo').textContent = `Waiting for ${playerName} to give a clue.`;
    el('clueSection').style.display = 'none';
  }
}

// pick random word from Firebase /words
async function getRandomWord() {
  const snap = await get(ref(db, 'words'));
  const wordsObj = snap.val() || {};
  const wordsArr = Object.values(wordsObj).filter(Boolean);
  if(wordsArr.length === 0) return 'unknown';
  return wordsArr[Math.floor(Math.random() * wordsArr.length)];
}

// create / join / start lobby
async function createLobby(){
  const name = el('name').value.trim();
  if(!name) return alert('Enter your name');
  const code = Math.random().toString(36).substring(2,8).toUpperCase();
  currentLobby = code;
  await set(ref(db, 'lobbies/' + code), { hostId: clientId, started: false, created: serverTimestamp() });
  await set(ref(db, 'lobbies/' + code + '/players/' + clientId), { name, clientId });
  el('playersCard').style.display = 'block';
  el('codeDisplay').textContent = code;
  listenLobby(code);
}

async function joinLobby(){
  const name = el('name').value.trim();
  const code = el('joinCode').value.trim().toUpperCase();
  if(!name || !code) return alert('Enter name and code');
  const snap = await get(ref(db, 'lobbies/' + code));
  if(!snap.exists()) return alert('Lobby not found');
  currentLobby = code;
  await set(ref(db, 'lobbies/' + code + '/players/' + clientId), { name, clientId });
  el('playersCard').style.display = 'block';
  el('codeDisplay').textContent = code;
  listenLobby(code);
}

async function startGame(){
  if(!currentLobby) return;
  const snap = await get(ref(db, 'lobbies/' + currentLobby));
  const lobby = snap.val();
  const players = lobby.players || {};
  const keys = Object.keys(players);
  if(keys.length < 3) return alert('Need at least 3 players');

  const imposter = keys[Math.floor(Math.random()*keys.length)];
  const word = await getRandomWord();
  const turnOrder = keys.slice().sort(()=>Math.random()-0.5);

  const updates = {
    started: true,
    voting: false,
    word,
    turnOrder,
    currentTurn: 0,
    clues: [],
    round: 1
  };

  keys.forEach(k=>{
    updates['players/' + k + '/role'] = (k === imposter) ? 'imposter' : 'player';
  });

  await update(ref(db, 'lobbies/' + currentLobby), updates);
  await set(ref(db, 'lobbies/' + currentLobby + '/votes'), {});
}

// event listeners
el('createBtn').onclick = createLobby;
el('joinBtn').onclick = joinLobby;
el('startBtn').onclick = startGame;
el('submitClueBtn').onclick = submitClue;
el('submitVoteBtn').onclick = submitVote;

// listen lobby
function listenLobby(code){
  currentLobby = code;
  const lobbyRef = ref(db, 'lobbies/' + code);
  onValue(lobbyRef, snap=>{
    const data = snap.val();
    if(!data) return;
    renderPlayers(data.players || {});
    updateStartVisibility(data.hostId, data.players || {});
    el('lobbyCard').style.display = data.started ? 'none' : 'block';
    el('gameUI').style.display = data.started ? 'block' : 'none';
    if(data.started){
      const role = data.players?.[clientId]?.role || 'Unknown';
      el('roleDisplay').textContent = 'Your role: ' + role;
      el('wordDisplay').textContent = 'Word: ' + (role === 'imposter' ? '???' : (data.word || '-'));
      renderClues(data.clues || [], data.players || {});
      updateTurnUI(data);
    } else {
      // clear game UI hints when not started
      el('roleDisplay').textContent = 'Role: -';
      el('wordDisplay').textContent = 'Word: -';
      el('clueList').innerHTML = '';
      el('results').innerHTML = '';
      el('voteList').innerHTML = '';
    }
  });
}

// submit a clue and advance turn; when full round complete, start voting
async function submitClue(){
  if(!currentLobby) return alert('Not in a lobby');
  const text = el('clueInput').value.trim();
  if(!text) return alert('Enter a clue');
  // simple safeguard: do not allow exact word if present in word display (client-side best-effort)
  const snap = await get(ref(db, 'lobbies/' + currentLobby));
  const lobby = snap.val();
  if(!lobby) return alert('Lobby not found');
  const players = lobby.players || {};
  const order = lobby.turnOrder || Object.keys(players || {});
  const curIdx = typeof lobby.currentTurn === 'number' ? lobby.currentTurn : 0;

  // append clue array (read-modify-write - acceptable for casual use)
  const newClues = (lobby.clues || []).slice();
  newClues.push({ player: clientId, text, ts: Date.now() });

  const updates = {};
  updates['clues'] = newClues;

  // advance turn
  const nextIdx = (curIdx + 1) % (order.length || 1);
  updates['currentTurn'] = nextIdx;

  // if we've cycled back to 0 then whole round finished -> enter voting
  if(nextIdx === 0){
    updates['voting'] = true;
    // keep round number (increment)
    updates['round'] = (lobby.round || 1);
  }

  await update(ref(db, 'lobbies/' + currentLobby), updates);
  el('clueInput').value = '';
}

// render vote choices
function renderVoteList(lobby){
  const players = lobby.players || {};
  const keys = Object.keys(players);
  const container = el('voteList');
  container.innerHTML = '';
  keys.forEach(k=>{
    const row = document.createElement('div');
    row.style.marginBottom = '6px';
    const label = document.createElement('label');
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    const radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'vote';
    radio.value = k;
    radio.style.marginRight = '8px';
    label.appendChild(radio);
    label.appendChild(document.createTextNode(players[k].name || 'Unknown'));
    row.appendChild(label);
    container.appendChild(row);
  });
}

// submit vote and when all voted tally and show results
async function submitVote(){
  if(!currentLobby) return alert('Not in a lobby');
  const sel = document.querySelector('input[name="vote"]:checked');
  if(!sel) return alert('Choose someone to vote for');
  const votedFor = sel.value;
  const voteRef = ref(db, 'lobbies/' + currentLobby + '/votes/' + clientId);
  // set vote
  await set(voteRef, votedFor);

  // check if all players have voted
  const snap = await get(ref(db, 'lobbies/' + currentLobby));
  const lobby = snap.val();
  if(!lobby) return;
  const players = lobby.players || {};
  const votes = lobby.votes || {};
  const playerCount = Object.keys(players).length;
  const voteCount = Object.keys(votes).length;

  // if not all voted yet, just inform user
  if(voteCount < playerCount){
    alert('Vote recorded. Waiting for others.');
    return;
  }

  // tally votes
  const tally = {};
  Object.values(votes).forEach(v=>{
    tally[v] = (tally[v] || 0) + 1;
  });
  // find max
  let topId = null, topCount = 0;
  Object.entries(tally).forEach(([pid, ct])=>{
    if(ct > topCount){ topCount = ct; topId = pid; }
  });

  const imposterId = Object.keys(lobby.players || {}).find(k => (lobby.players[k] || {}).role === 'imposter');

  const chosenName = lobby.players?.[topId]?.name || 'Unknown';
  const imposterName = lobby.players?.[imposterId]?.name || 'Unknown';

  const resultsEl = el('results');
  let html = `<strong>Voting results</strong><br/>Chosen: ${escapeHtml(chosenName)} (${topCount} vote${topCount>1?'s':''})<br/>Actual imposter: ${escapeHtml(imposterName)}<br/>`;
  html += (topId === imposterId) ? '<div class="small">They guessed correctly.</div>' : '<div class="small">They guessed wrong.</div>';

  resultsEl.innerHTML = html;

  // end game: reset started to false so players see lobby again
  // optionally you could keep a history or let host restart; here we reset for simplicity
  await update(ref(db, 'lobbies/' + currentLobby), {
    started: false,
    voting: false
  });
  // clear votes and clues for next game
  await set(ref(db, 'lobbies/' + currentLobby + '/votes'), {});
  await set(ref(db, 'lobbies/' + currentLobby + '/clues'), []);
}

</script>
</body>
</html>
